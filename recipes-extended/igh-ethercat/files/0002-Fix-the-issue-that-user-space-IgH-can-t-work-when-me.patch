From 1c54b943a2d9955889b82c5b916a46c814ab96e2 Mon Sep 17 00:00:00 2001
From: Hongbo Wang <hongbo.wang@nxp.com>
Date: Mon, 18 Mar 2024 03:47:39 +0000
Subject: [PATCH 2/5] Fix the issue that user space IgH can't work when memory
 is larger that 4GB

if user's board has larger memory than 4G bytes,
using this patch, don't need limit memory in 4GB.

user should allocate enough hugepages firstly, make sure that there are
hugepages within 4G bytes, like following:
  echo 2048 > /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages

then allocate hugepage for user space IgH, after that user can free surplus
hugepage to Linux kernel, like this:
  echo 64 > /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages

Signed-off-by: Hongbo Wang <hongbo.wang@nxp.com>
---
 devices/enet_fec/enet_fec.c | 39 +++++++++++++++++++++++++++++--------
 1 file changed, 31 insertions(+), 8 deletions(-)

diff --git a/devices/enet_fec/enet_fec.c b/devices/enet_fec/enet_fec.c
index 56ffbe9b..73595e68 100644
--- a/devices/enet_fec/enet_fec.c
+++ b/devices/enet_fec/enet_fec.c
@@ -4,6 +4,7 @@
 
 #include <sys/mman.h>
 #include <sys/stat.h>
+#include <sys/sysinfo.h>
 #include <fcntl.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -18,6 +19,7 @@ static struct enet_fec_bd_buf_t senet_fec_bd_buf;
 
 #define HUGE_PAGE_MNT_PATH ("/dev/hugepages/ecat_hugepage")
 #define HUGE_PAGE_SIZE (0x200000)
+#define MEM_4G_SIZE (0x100000000)
 #define NUM_HUGE_PAGE (16)
 #define HP_DIR_LEN (256)
 
@@ -81,6 +83,8 @@ void* enet_fec_mem_map(size_t length, uint32_t *pa, uint32_t align)
 	char *hp_dir = NULL;
 	void *pbase = NULL;
 	void *pvirt = NULL;
+	struct sysinfo si;
+	off_t offset = 0;
 	off_t addr = 0;
 	int fd = 0;
 
@@ -110,15 +114,34 @@ void* enet_fec_mem_map(size_t length, uint32_t *pa, uint32_t align)
 		return NULL;
 	}
 
-	pbase = mmap(NULL, length, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
-	if (pbase == MAP_FAILED) {
-		printf("%s(): mmap failed! ret:%p\n", __func__, pbase);
-		free(hp_dir);
-		return NULL;
-	}
+	sysinfo(&si);
+	do {
+		pbase = mmap(NULL, length, PROT_READ | PROT_WRITE, MAP_SHARED, fd, offset);
+		if (pbase == MAP_FAILED) {
+			free(hp_dir);
+			printf("%s(): mmap failed! Try to set more PAGE_NUM using:\n", __func__);
+			printf("# echo $PAGE_NUM > /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages\n\n");
+			return NULL;
+		}
 
-	*(volatile int *)pbase = *(volatile int *)pbase;
-	addr = rte_mem_virt2phy(pbase);
+		*(volatile int *)pbase = *(volatile int *)pbase;
+		addr = rte_mem_virt2phy(pbase);
+
+		if (si.totalram < MEM_4G_SIZE)
+			break;
+
+		if (addr >= MEM_4G_SIZE) {
+			munmap(pbase, length);  /* unmap the memory that's upper than 4GB */
+			pbase = NULL;
+
+			if (offset == 0)
+				offset = MEM_4G_SIZE - HUGE_PAGE_SIZE * 2;
+			else
+				offset = addr - HUGE_PAGE_SIZE;
+		} else {
+			break;
+		}
+	} while (!pbase);
 
 	php = shp_info + shp_cnt++;
 	memset(php, 0, sizeof(*php));
-- 
2.34.1

